
__E__lastic __Net__ Regression in __S__cala

Enets is a simple framework for estimating generalized and robust linear models with elastic net regularization in scala.  

Current, the GLMs supporting include
* Gaussian
* Poisson
* Negative Binomial and
* Binomial 

and RLMs include the following robust norms
* Huber
* Approximate (Smooth) Huber
* Tukey
* L1
* Trimmed Mean
* Ramsay
* Cauchy



```scala211
// add breeze for linear algebra
classpath.add("org.scalanlp" %% "breeze" % "0.13.2",
    "org.scalanlp" %% "breeze-natives" % "0.13.2",
    "org.scalanlp" %% "breeze-viz" % "0.13.2")
```

    40 new artifact(s)

    40 new artifacts in macro


    


    40 new artifacts in runtime
    40 new artifacts in compile
    


    



```scala211
// add enets
classpath.addPath("../target/scala-2.11/enets_2.11-1.0.jar")
```


    



```scala211
import java.io.File
import breeze.linalg.csvread
import breeze.stats.median
import com.github.timsetsfire.enets._
import com.github.timsetsfire.enets.robust.norms._
```


    [32mimport [36mjava.io.File[0m
    [32mimport [36mbreeze.linalg.csvread[0m
    [32mimport [36mbreeze.stats.median[0m
    [32mimport [36mbreeze.stats.distributions.Gaussian[0m
    [32mimport [36mcom.github.timsetsfire.enets._[0m
    [32mimport [36mcom.github.timsetsfire.enets.robust.norms._[0m



```scala211
// import boston dataset 
val x = csvread(new File("../resources/bostonX.csv"));
val y = csvread(new File("../resources/bostonY.csv")).toDenseVector;
```


    [36mx[0m: [32mbreeze[0m.[32mlinalg[0m.[32mDenseMatrix[0m[[32mDouble[0m] = 0.00632  18.0   2.31   0.0  0.538   6.575  65.2   4.09    1.0  ... (13 total)
    0.02731  0.0    7.07   0.0  0.469   6.421  78.9   4.9671  2.0  ...
    0.02729  0.0    7.07   0.0  0.469   7.185  61.1   4.9671  2.0  ...
    0.03237  0.0    2.18   0.0  0.458   6.998  45.8   6.0622  3.0  ...
    0.06905  0.0    2.18   0.0  0.458   7.147  54.2   6.0622  3.0  ...
    0.02985  0.0    2.18   0.0  0.458   6.43   58.7   6.0622  3.0  ...
    0.08829  12.5   7.87   0.0  0.524   6.012  66.6   5.5605  5.0  ...
    0.14455  12.5   7.87   0.0  0.524   6.172  96.1   5.9505  5.0  ...
    0.21124  12.5   7.87   0.0  0.524   5.631  100.0  6.0821  5.0  ...
    0.17004  12.5   7.87   0.0  0.524   6.004  85.9   6.5921  5.0  ...
    0.22489  12.5   7.87   0.0  0.524   6.377  94.3   6.3467  5.0  ...
    0.11747  12.5   7.87   0.0  0.524   6.009  82.9   6.2267  5.0  ...
    0.09378  12.5   7.87   0.0  0.524   5.889  39.0   5.4509  5.0  ...
    0.62976  0.0    8.14   0.0  0.538   5.949  61.8   4.7075  4.0  ...
    0.63796  0.0    8.14   0.0  0.538   6.096  84.5   4.4619  4.0  ...
    0.62739  0.0    8.14   0.0  0.538   5.834  56.5   4.4986  4.0  ...
    1.05393  0.0    8.14   0.0  0.538   5.935  29.3   4.4986  4.0  ...
    0.7842   0.0    8.14   0.0  0.538   5.99   81.7   4.2579  4.0  ...
    0.80271  0.0    8.14   0.0  0.538   5.456  36.6   3.7965  4.0  ...
    0.7258   0.0    8.14   0.0  0.538   5.727  69.5   3.7965  4.0  ...
    [33m...[0m
    [36my[0m: [32mbreeze[0m.[32mlinalg[0m.[32mDenseVector[0m[[32mDouble[0m] = DenseVector(24.0, 21.6, 34.7, 33.4, 36.2, 28.7, 22.9, 27.1, 16.5, 18.9, 15.0, 18.9, 21.7, 20.4, 18.2, 19.9, 23.1, 17.5, 20.2, 18.2, 13.6, 19.6, 15.2, 14.5, 15.6, 13.9, 16.6, 14.8, 18.4, 21.0, 12.7, 14.5, 13.2, 13.1, 13.5, 18.9, 20.0, 21.0, 24.7, 30.8, 34.9, 26.6, 25.3, 24.7, 21.2, 19.3, 20.0, 16.6, 14.4, 19.4, 19.7, 20.5, 25.0, 23.4, 18.9, 35.4, 24.7, 31.6, 23.3, 19.6, 18.7, 16.0, 22.2, 25.0, 33.0, 23.5, 19.4, 22.0, 17.4, 20.9, 24.2, 21.7, 22.8, 23.4, 24.1, 21.4, 20.0, 20.8, 21.2, 20.3, 28.0, 23.9, 24.8, 22.9, 23.9, 26.6, 22.5, 22.2, 23.6, 28.7, 22.6, 22.0, 22.9, 25.0, 20.6, 28.4, 21.4, 38.7, 43.8, 33.2, 27.5, 26.5, 18.6, 19.3, 20.1, 19.5, 19.5, 20.4, 19.8, 19.4, 21.7, 22.8, 18.8, 18.7, 18.5, 18.3, 21.2, 19.2, 20.4, 19.3, 22.0, 20.3, 20.5, 17.3, 18.8, 21.4, 15.7, 16.2, 18.0, 14.3, 19.2, 19.6, 23.0, 18.4, 15.6, 18.1, 17.4, 17.1, 13.3, 17.8, 14.0, 14.4, 13.4, 15.6, 11.8, 13.8, 15.6, 14.6, 17.8, 15.4, 21.5, 19.6, 15.3, 19.4, 17.0, 15.6, 13.1, 41.3, 24.3, 23.3, 27.0, 50.0, 50.0, 50.0, 22.7, 25.0, 50.0, 23.8, 23.8, 22.3, 17.4, 19.1, 23.1, 23.6, 22.6, 29.4, 23.2, 24.6, 29.9, 37.2, 39.8, 36.2, 37.9, 32.5, 26.4, 29.6, 50.0, 32.0, 29.8, 34.9, 37.0, 30.5, 36.4, 31.1, 29.1, 50.0, 33.3, 30.3, 34.6, 34.9, 32.9, 24.1, 42.3, 48.5, 50.0, 22.6, 24.4, 22.5, 24.4, 20.0, 21.7, 19.3, 22.4, 28.1, 23.7, 25.0, 23.3, 28.7, 21.5, 23.0, 26.7, 21.7, 27.5, 30.1, 44.8, 50.0, 37.6, 31.6, 46.7, 31.5, 24.3, 31.7, 41.7, 48.3, 29.0, 24.0, 25.1, 31.5, 23.7, 23.3, 22.0, 20.1, 22.2, 23.7, 17.6, 18.5, 24.3, 20.5, 24.5, 26.2, 24.4, 24.8, 29.6, 42.8, 21.9, 20.9, 44.0, 50.0, 36.0, 30.1, 33.8, 43.1, 48.8, 31.0, 36.5[33m...[0m



```scala211
val glmnet = new GlmNet(x,y,standardizeTarget=true)
// features are standardized by default
// fit glmnet
glmnet.fit
// no inline plotting available, this will popup in a new window
glmnet.plotCoordinatePath
```


    [36mglmnet[0m: [32mGlmNet[0m = com.github.timsetsfire.enets.GlmNet@2779f927



```scala211
// fit RlmNet
val rlmnet = new RlmNet(x,y,rnorm=HuberT(),standardizeTarget=true) // default norm is least squares
rlmnet.fit
rlmnet.plotCoordinatePath
```


    [36mrlmnet[0m: [32mRlmNet[0m = com.github.timsetsfire.enets.RlmNet@68f4db62



```scala211
val yMed = median(y)
val g = y.map{ element => if(element > yMed) 1d else 0d }
```


    [36myMed[0m: [32mDouble[0m = [32m21.2[0m
    [36mg[0m: [32mbreeze[0m.[32mlinalg[0m.[32mDenseVector[0m[[32mDouble[0m] = DenseVector(1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0[33m...[0m



```scala211
// fit a logistic regression 
val lr = new GlmNet(x,g,family="binomial", link="logit")
lr.fit
lr.plotCoordinatePath
```


    [36mlr[0m: [32mGlmNet[0m = com.github.timsetsfire.enets.GlmNet@4448b7a9



```scala211
import breeze.numerics.sigmoid 
val yhat = sigmoid(lr.x * lr.b(::, 30) + lr.b0(30)) map{ p => if(p > 0.5) 1d else 0d}
```


    [32mimport [36mbreeze.numerics.sigmoid[0m
    [36myhat[0m: [32mbreeze[0m.[32mlinalg[0m.[32mDenseVector[0m[[32mDouble[0m] = DenseVector(1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0[33m...[0m



```scala211
val nCorrect = g.toArray zip yhat.toArray map{ case(actual, prediction) => if(actual == prediction) 1d else 0d} sum
```


    [36mnCorrect[0m: [32mDouble[0m = [32m438.0[0m



```scala211
println(f"accuracy: ${nCorrect / g.length * 100}%2.2f" + "%")
```

    accuracy: 86.56%



    



```scala211
lr.b(::, 30)
```


    [36mres39[0m: [32mbreeze[0m.[32mlinalg[0m.[32mDenseVector[0m[[32mDouble[0m] = DenseVector(0.0, 0.0, 0.0, 0.2174172595751625, -0.039428668209070004, 0.5951370435652193, -0.1840802749542785, -0.14483677421508095, 0.0, 0.0, -0.5863024775047501, 0.13089718770906264, -1.7598869029266286)

